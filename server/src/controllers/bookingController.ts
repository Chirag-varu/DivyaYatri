import { Request, Response } from 'express';\nimport Booking from '../models/Booking';\nimport Temple from '../models/Temple';\nimport Notification from '../models/Notification';\nimport { generateQRCode } from '../utils/qrCode';\nimport { sendEmail } from '../utils/email';\nimport { validateBookingSlot } from '../utils/booking';\n\n// Get all bookings for a user\nexport const getUserBookings = async (req: Request, res: Response) => {\n  try {\n    const { page = 1, limit = 10, status } = req.query;\n    const userId = req.user?._id;\n\n    const query: any = { user: userId };\n    if (status) {\n      query.bookingStatus = status;\n    }\n\n    const bookings = await Booking.find(query)\n      .populate('temple', 'name city state images')\n      .sort({ createdAt: -1 })\n      .limit(Number(limit))\n      .skip((Number(page) - 1) * Number(limit));\n\n    const total = await Booking.countDocuments(query);\n\n    res.json({\n      success: true,\n      data: {\n        bookings,\n        pagination: {\n          page: Number(page),\n          limit: Number(limit),\n          total,\n          pages: Math.ceil(total / Number(limit))\n        }\n      }\n    });\n  } catch (error) {\n    res.status(500).json({\n      success: false,\n      message: 'Error fetching user bookings',\n      error: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n};\n\n// Get booking by ID\nexport const getBookingById = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n    const userId = req.user?._id;\n\n    const booking = await Booking.findOne({\n      _id: id,\n      user: userId\n    }).populate('temple', 'name city state address contact timings images');\n\n    if (!booking) {\n      return res.status(404).json({\n        success: false,\n        message: 'Booking not found'\n      });\n    }\n\n    res.json({\n      success: true,\n      data: { booking }\n    });\n  } catch (error) {\n    res.status(500).json({\n      success: false,\n      message: 'Error fetching booking',\n      error: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n};\n\n// Create new booking\nexport const createBooking = async (req: Request, res: Response) => {\n  try {\n    const {\n      templeId,\n      visitDate,\n      timeSlot,\n      visitors,\n      contactInfo,\n      paymentMethod,\n      specialRequests\n    } = req.body;\n\n    const userId = req.user?._id;\n\n    // Validate temple exists\n    const temple = await Temple.findById(templeId);\n    if (!temple) {\n      return res.status(404).json({\n        success: false,\n        message: 'Temple not found'\n      });\n    }\n\n    // Validate time slot availability\n    const isSlotAvailable = await validateBookingSlot(\n      templeId,\n      new Date(visitDate),\n      timeSlot.start,\n      timeSlot.end\n    );\n\n    if (!isSlotAvailable) {\n      return res.status(400).json({\n        success: false,\n        message: 'Selected time slot is not available'\n      });\n    }\n\n    // Calculate pricing\n    const basePrice = 50; // Base price per adult\n    const childPrice = 25; // Price per child\n    const seniorPrice = 40; // Price per senior\n    \n    const totalAmount = \n      (visitors.adults * basePrice) +\n      (visitors.children * childPrice) +\n      (visitors.seniors * seniorPrice);\n    \n    const serviceFee = Math.round(totalAmount * 0.05); // 5% service fee\n    const finalAmount = totalAmount + serviceFee;\n\n    // Create booking\n    const booking = new Booking({\n      temple: templeId,\n      user: userId,\n      visitDate: new Date(visitDate),\n      timeSlot,\n      visitors,\n      totalAmount,\n      serviceFee,\n      finalAmount,\n      contactInfo: {\n        ...contactInfo,\n        specialRequests\n      },\n      paymentInfo: {\n        paymentMethod,\n        paymentStatus: 'pending'\n      },\n      metadata: {\n        source: 'web',\n        userAgent: req.get('User-Agent'),\n        ipAddress: req.ip\n      }\n    });\n\n    await booking.save();\n\n    // Generate QR code\n    const qrCode = await generateQRCode(booking._id.toString());\n    booking.qrCode = qrCode;\n    await booking.save();\n\n    // Send confirmation email\n    await sendEmail({\n      to: contactInfo.email,\n      subject: 'Booking Confirmation - DivyaYatri',\n      template: 'booking-confirmation',\n      data: {\n        booking,\n        temple,\n        qrCode\n      }\n    });\n\n    // Create notification\n    await Notification.create({\n      recipient: userId,\n      type: 'booking_confirmed',\n      title: 'Booking Confirmed',\n      message: `Your visit to ${temple.name} has been confirmed for ${booking.formattedVisitDate}`,\n      data: {\n        bookingId: booking._id,\n        templeId: temple._id,\n        actionUrl: `/bookings/${booking._id}`\n      },\n      priority: 'high'\n    });\n\n    await booking.populate('temple', 'name city state images');\n\n    res.status(201).json({\n      success: true,\n      message: 'Booking created successfully',\n      data: { booking }\n    });\n  } catch (error) {\n    res.status(500).json({\n      success: false,\n      message: 'Error creating booking',\n      error: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n};\n\n// Update booking payment status\nexport const updatePaymentStatus = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n    const { paymentId, transactionId, paymentStatus } = req.body;\n    const userId = req.user?._id;\n\n    const booking = await Booking.findOne({\n      _id: id,\n      user: userId\n    });\n\n    if (!booking) {\n      return res.status(404).json({\n        success: false,\n        message: 'Booking not found'\n      });\n    }\n\n    // Update payment info\n    booking.paymentInfo.paymentId = paymentId;\n    booking.paymentInfo.transactionId = transactionId;\n    booking.paymentInfo.paymentStatus = paymentStatus;\n    \n    if (paymentStatus === 'completed') {\n      booking.paymentInfo.paidAt = new Date();\n      booking.bookingStatus = 'confirmed';\n    } else if (paymentStatus === 'failed') {\n      booking.bookingStatus = 'cancelled';\n      booking.cancellationReason = 'Payment failed';\n    }\n\n    await booking.save();\n\n    // Create notification based on payment status\n    const notificationType = paymentStatus === 'completed' ? 'payment_success' : 'payment_failed';\n    const title = paymentStatus === 'completed' ? 'Payment Successful' : 'Payment Failed';\n    const message = paymentStatus === 'completed' \n      ? `Payment of ₹${booking.finalAmount} completed successfully`\n      : 'Payment failed. Please try again or contact support';\n\n    await Notification.create({\n      recipient: userId,\n      type: notificationType,\n      title,\n      message,\n      data: {\n        bookingId: booking._id,\n        actionUrl: `/bookings/${booking._id}`\n      },\n      priority: paymentStatus === 'failed' ? 'high' : 'medium'\n    });\n\n    res.json({\n      success: true,\n      message: 'Payment status updated successfully',\n      data: { booking }\n    });\n  } catch (error) {\n    res.status(500).json({\n      success: false,\n      message: 'Error updating payment status',\n      error: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n};\n\n// Cancel booking\nexport const cancelBooking = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n    const { reason } = req.body;\n    const userId = req.user?._id;\n\n    const booking = await Booking.findOne({\n      _id: id,\n      user: userId\n    });\n\n    if (!booking) {\n      return res.status(404).json({\n        success: false,\n        message: 'Booking not found'\n      });\n    }\n\n    if (!booking.canBeCancelled()) {\n      return res.status(400).json({\n        success: false,\n        message: 'Booking cannot be cancelled. Cancellation is only allowed 24 hours before the visit.'\n      });\n    }\n\n    // Calculate refund\n    const refundAmount = booking.calculateRefund();\n    \n    booking.bookingStatus = 'cancelled';\n    booking.cancellationReason = reason;\n    booking.refundAmount = refundAmount;\n    booking.refundStatus = refundAmount > 0 ? 'pending' : undefined;\n\n    await booking.save();\n\n    // Send cancellation email\n    await sendEmail({\n      to: booking.contactInfo.email,\n      subject: 'Booking Cancelled - DivyaYatri',\n      template: 'booking-cancelled',\n      data: {\n        booking,\n        refundAmount\n      }\n    });\n\n    // Create notification\n    await Notification.create({\n      recipient: userId,\n      type: 'booking_cancelled',\n      title: 'Booking Cancelled',\n      message: `Your booking has been cancelled. ${refundAmount > 0 ? `Refund of ₹${refundAmount} will be processed.` : ''}`,\n      data: {\n        bookingId: booking._id,\n        actionUrl: `/bookings/${booking._id}`\n      },\n      priority: 'medium'\n    });\n\n    res.json({\n      success: true,\n      message: 'Booking cancelled successfully',\n      data: { booking, refundAmount }\n    });\n  } catch (error) {\n    res.status(500).json({\n      success: false,\n      message: 'Error cancelling booking',\n      error: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n};\n\n// Get available time slots for a temple\nexport const getAvailableSlots = async (req: Request, res: Response) => {\n  try {\n    const { templeId } = req.params;\n    const { date } = req.query;\n\n    if (!date) {\n      return res.status(400).json({\n        success: false,\n        message: 'Date is required'\n      });\n    }\n\n    const temple = await Temple.findById(templeId);\n    if (!temple) {\n      return res.status(404).json({\n        success: false,\n        message: 'Temple not found'\n      });\n    }\n\n    const requestedDate = new Date(date as string);\n    \n    // Get existing bookings for the date\n    const existingBookings = await Booking.find({\n      temple: templeId,\n      visitDate: {\n        $gte: new Date(requestedDate.setHours(0, 0, 0, 0)),\n        $lt: new Date(requestedDate.setHours(23, 59, 59, 999))\n      },\n      bookingStatus: { $in: ['confirmed', 'pending'] }\n    });\n\n    // Generate time slots based on temple timings\n    const openTime = temple.timings.open;\n    const closeTime = temple.timings.close;\n    const slotDuration = 60; // 1 hour slots\n    const maxVisitorsPerSlot = 50;\n\n    const slots = [];\n    let currentTime = parseTime(openTime);\n    const endTime = parseTime(closeTime);\n\n    while (currentTime < endTime) {\n      const slotStart = formatTime(currentTime);\n      currentTime += slotDuration;\n      const slotEnd = formatTime(currentTime);\n\n      // Count existing bookings for this slot\n      const slotBookings = existingBookings.filter(booking => \n        booking.timeSlot.start === slotStart && booking.timeSlot.end === slotEnd\n      );\n\n      const bookedVisitors = slotBookings.reduce((total, booking) => \n        total + booking.totalVisitors, 0\n      );\n\n      const availableSpots = maxVisitorsPerSlot - bookedVisitors;\n\n      slots.push({\n        start: slotStart,\n        end: slotEnd,\n        available: availableSpots > 0,\n        availableSpots,\n        maxCapacity: maxVisitorsPerSlot\n      });\n    }\n\n    res.json({\n      success: true,\n      data: { slots }\n    });\n  } catch (error) {\n    res.status(500).json({\n      success: false,\n      message: 'Error fetching available slots',\n      error: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n};\n\n// Helper functions\nfunction parseTime(timeStr: string): number {\n  const [hours, minutes] = timeStr.split(':').map(Number);\n  return hours * 60 + minutes;\n}\n\nfunction formatTime(minutes: number): string {\n  const hours = Math.floor(minutes / 60);\n  const mins = minutes % 60;\n  return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;\n}\n\n// Check-in booking\nexport const checkInBooking = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n    const userId = req.user?._id;\n\n    const booking = await Booking.findOne({\n      _id: id,\n      user: userId,\n      bookingStatus: 'confirmed'\n    });\n\n    if (!booking) {\n      return res.status(404).json({\n        success: false,\n        message: 'Booking not found or not confirmed'\n      });\n    }\n\n    // Check if it's the right date and time\n    const now = new Date();\n    const visitDate = new Date(booking.visitDate);\n    \n    if (now.toDateString() !== visitDate.toDateString()) {\n      return res.status(400).json({\n        success: false,\n        message: 'Check-in is only allowed on the visit date'\n      });\n    }\n\n    booking.checkInTime = now;\n    await booking.save();\n\n    res.json({\n      success: true,\n      message: 'Checked in successfully',\n      data: { booking }\n    });\n  } catch (error) {\n    res.status(500).json({\n      success: false,\n      message: 'Error checking in',\n      error: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n};\n\n// Complete booking (check-out)\nexport const completeBooking = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n    const { rating, feedback } = req.body;\n    const userId = req.user?._id;\n\n    const booking = await Booking.findOne({\n      _id: id,\n      user: userId\n    });\n\n    if (!booking) {\n      return res.status(404).json({\n        success: false,\n        message: 'Booking not found'\n      });\n    }\n\n    if (!booking.checkInTime) {\n      return res.status(400).json({\n        success: false,\n        message: 'Cannot complete booking without check-in'\n      });\n    }\n\n    booking.checkOutTime = new Date();\n    booking.bookingStatus = 'completed';\n    \n    if (rating) {\n      booking.rating = rating;\n    }\n    \n    if (feedback) {\n      booking.feedback = feedback;\n    }\n\n    await booking.save();\n\n    res.json({\n      success: true,\n      message: 'Booking completed successfully',\n      data: { booking }\n    });\n  } catch (error) {\n    res.status(500).json({\n      success: false,\n      message: 'Error completing booking',\n      error: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n};